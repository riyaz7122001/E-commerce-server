let path = require('path');
let fs = require('fs');
let Task = require('./task/task').Task;

// Split a task to two parts, name space and task name.
// For example, given 'foo:bin/a%.c', return an object with
// - 'ns'     : foo
// - 'name'   : bin/a%.c
function splitNs(task) {
  let parts = task.split(':');
  let name = parts.pop();
  let ns = resolveNs(parts);
  return {
    'name' : name,
    'ns'   : ns
  };
}

// Return the namespace based on an array of names.
// For example, given ['foo', 'baz' ], return the namespace
//
//   default -> foo -> baz
//
// where default is the global root namespace
// and -> means child namespace.
function resolveNs(parts) {
  let  ns = jake.defaultNamespace;
  for(let i = 0, l = parts.length; ns && i < l; i++) {
    ns = ns.childNamespaces[parts[i]];
  }
  return ns;
}

// Given a pattern p, say 'foo:bin/a%.c'
// Return an object with
// - 'ns'     : foo
// - 'dir'    : bin
// - 'prefix' : a
// - 'suffix' : .c
function resolve(p) {
  let task = splitNs(p);
  let name  = task.name;
  let ns    = task.ns;
  let split = path.basename(name).split('%');
  return {
    ns: ns,
    dir: path.dirname(name),
    prefix: split[0],
    suffix: split[1]
  };
}

// Test whether string a is a suffix of string b
function stringEndWith(a, b) {
  let l;
  return (l = b.lastIndexOf(a)) == -1 ? false : l + a.length == b.length;
}

// Replace the suffix a of the string s with b.
// Note that, it is assumed a is a suffix of s.
function stringReplaceSuffix(s, a, b) {
  return s.slice(0, s.lastIndexOf(a)) + b;
}

class Rule {
  constructor(opts) {
    this.pattern = opts.pattern;
    this.source = opts.source;
    this.prereqs = opts.prereqs;
    this.action = opts.action;
    this.opts = opts.opts;
    this.desc =  opts.desc;
    this.ns = opts.ns;
  }

  // Create a file task based on this rule for the specified
  // task-name
  // ======
  // FIXME: Right now this just throws away any passed-in args
  // for the synthsized task (taskArgs param)
  // ======
  createTask(fullName, level) {
    let self = this;
    let pattern;
    let source;
    let action;
    let opts;
    let prereqs;
    let valid;
    let src;
    let tNs;
    let createdTask;
    let name = Task.getBaseTaskName(fullName);
    let nsPath = Task.getBaseNamespacePath(fullName);
    let ns = this.ns.resolveNamespace(nsPath);

    pattern = this.pattern;
    source = this.source;

    if (typeof source == 'string') {
      src = Rule.getSource(name, pattern, source);
    }
    else {
      src = source(name);
    }

    // TODO: Write a utility function that appends a
    // taskname to a namespace path
    src = nsPath.split(':').filter(function (item) {
      return !!item;
    }).concat(src).join(':');

    // Generate the prerequisite for the matching task.
    //    It is the original prerequisites plus the prerequisite
    //    representing source file, i.e.,
    //
    //      rule( '%.o', '%.c', ['some.h'] ...
    //
    //    If the objective is main.o, then new task should be
    //
    //      file( 'main.o', ['main.c', 'some.h' ] ...
    prereqs = this.prereqs.slice(); // Get a copy to work with
    prereqs.unshift(src);

    // Prereq should be:
    // 1. an existing task
    // 2. an existing file on disk
    // 3. a valid rule (i.e., not at too deep a level)
    valid = prereqs.some(function (p) {
      let ns = self.ns;
      return ns.resolveTask(p) ||
        fs.existsSync(Task.getBaseTaskName(p)) ||
        jake.attemptRule(p, ns, level + 1);
    });

    // If any of the prereqs aren't valid, the rule isn't valid